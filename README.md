# Symfony Overview

## 1. Введение

Этот репозиторий — короткий и понятный вход в мир **Symfony** — современного PHP-фреймворка для создания веб-приложений и API.

Здесь ты сможешь:

- быстро понять, **что такое Symfony** и чем он отличается от других фреймворков;
- узнать, **когда его имеет смысл использовать** (и когда, возможно, нет);
- получить **пошаговый гайд по запуску первого проекта**;
- посмотреть **примеры кода**: маршруты, контроллеры, шаблоны, работа с БД и API;
- увидеть, как вписать Symfony в привычный стек: Git, Docker, CI/CD, macOS.

> Цель: сделать так, чтобы после прочтения одного README ты мог(ла) развернуть рабочий проект на Symfony, понимать общую архитектуру и спокойно двигаться дальше по официальной документации и туториалам.

## 2. Что такое Symfony

**Symfony** — это современный, модульный **PHP-фреймворк** и одновременно **набор отдельных компонентов**, которые можно использовать как вместе, так и по отдельности.

Ключевые идеи Symfony:

- **Фреймворк полного стека**  
  Позволяет написать всё приложение “под ключ”: роутинг, контроллеры, шаблоны, формы, работа с БД, безопасность, консольные команды и т.д.

- **Набор компонентов**  
  Symfony состоит из десятков независимых компонент (Routing, HTTP Foundation, Console, EventDispatcher и др.), которые можно использовать в любом PHP-проекте, даже без самого фреймворка.

- **Сервис-контейнер и DI (Dependency Injection)**  
  Вся логика оформляется как сервисы, которыми управляет контейнер. Это упрощает тестирование, переиспользование и поддержку кода.

- **Гибкая архитектура**  
  Symfony не жёстко привязан к “чистому” MVC, но использует похожий подход: контроллеры принимают HTTP-запрос, вызывают доменную логику (сервисы/модели) и возвращают HTTP-ответ (чаще всего через шаблон Twig или JSON).

- **Enterprise-уровень**  
  Фреймворк ориентирован на долгоживущие, расширяемые проекты, с упором на стандарты, тестируемость и предсказуемые релизы (LTS-версии).

Если коротко: **Symfony — это фундамент для серьёзных веб-приложений и API**, который даёт строгую структуру, мощный набор инструментов и при этом остаётся достаточно гибким, чтобы подстроиться под архитектурный стиль проекта.

## 3. Основные возможности и преимущества Symfony

Symfony даёт целый набор мощных инструментов “из коробки”, которые помогают быстро писать поддерживаемый и расширяемый код.

### Ключевые возможности

- **Роутинг (Routing)**  
  Гибкая система маршрутизации: описываешь URL → указываешь, какой контроллер и метод должен выполниться. Поддерживаются параметры, требования (регекспы), префиксы, группы маршрутов и атрибуты в коде.

- **Контроллеры и HTTP-слой**  
  Контроллеры работают поверх компонента HttpFoundation: удобные объекты `Request` и `Response`, работа с сессией, файлами, куками, редиректами и т.д.

- **Шаблоны Twig**  
  Twig — быстрый и безопасный шаблонизатор: наследование шаблонов, блоки, фильтры, циклы, условия, защита от XSS по умолчанию. Отлично подходит для разметки HTML и email-шаблонов.

- **Работа с БД через Doctrine ORM**  
  Поддержка сущностей, миграций, репозиториев, связей (OneToMany, ManyToMany и т.п.). Можно описывать модель БД на PHP-классах и не писать “сырой” SQL везде.

- **Формы и валидация**  
  Мощный Form компонент: генерация HTML-форм, биндинг данных к объектам, валидация через аннотации/атрибуты/конфиг, удобные сообщения об ошибках.

- **Безопасность и аутентификация**  
  Готовые механизмы логина (form login, HTTP basic, JWT через бандлы), роли, права доступа, “firewalls”. Удобная защита маршрутов через конфиг и атрибуты.

- **Консольные команды**  
  Компонент Console позволяет создавать CLI-команды: миграции, крон-скрипты, задачи администрирования и обслуживание проекта.

- **Событийная модель и подписчики**  
  EventDispatcher позволяет “подслушивать” события фреймворка и своего приложения и реагировать на них без жёсткой связки частей кода.

---

### Почему Symfony стоит использовать

- **Строгая структура и стандарты**  
  Symfony придерживается PSR-стандартов, поощряет чистую архитектуру и делает код предсказуемым для всей команды.

- **Модульность и переиспользование**  
  Можно использовать как целый фреймворк, так и отдельные компоненты в любых PHP-проектах.

- **Масштабируемость**  
  Подходит и для небольших сервисов, и для крупных монолитов/enterprise-систем, которые развиваются годами.

- **Экосистема и сообщество**  
  Богатый набор бандлов, интеграция с популярными библиотеками, большое сообщество и хорошая документация.

- **Тестируемость**  
  Встроенная поддержка unit, functional и интеграционных тестов, удобная работа с моками и тестовым окружением.

> Идея: Symfony даёт не просто “набор функций”, а **целостный каркас** приложения, который помогает писать код, который легко развивать, тестировать и поддерживать в долгую.

## 4. Требования к окружению

Перед тем как начинать работать с Symfony, важно подготовить минимальное окружение.

### Версия PHP

Актуальные версии Symfony требуют современный PHP:

- Для свежих проектов рекомендуется PHP 8.2+ (уточняй в composer.json конкретной версии фреймворка).
- В продакшене желательно включённый opcache для производительности.

Проверить версию:
php -v

---

### Обязательные расширения PHP

Symfony опирается на ряд стандартных расширений PHP (обычно уже есть в нормальной сборке PHP):

- ctype
- iconv
- mbstring
- json
- openssl
- pcre
- session
- simplexml
- tokenizer
- xml

Плюс расширение для работы с нужной БД:
- pdo_mysql — для MySQL/MariaDB
- pdo_pgsql — для PostgreSQL
- pdo_sqlite — для SQLite

Посмотреть список расширений:
php -m

---

### Composer

Symfony использует Composer для управления зависимостями.

- Нужен глобально установленный Composer.
- Минимальная версия — актуальная стабильная (2.x).

Проверка:
composer -V

---

### Symfony CLI (рекомендуется)

Официальная утилита symfony упрощает жизнь:

- создание проектов: symfony new ...
- запуск локального сервера: symfony serve
- проверки окружения и т.п.

Проверка:
symfony version

---

### База данных (по необходимости)

Если планируется работа с БД (Doctrine ORM и т.п.), нужна любая поддерживаемая СУБД:

- MySQL / MariaDB
- PostgreSQL
- SQLite (для локальной разработки часто достаточно)

Опционально: Redis / RabbitMQ и другие, если нужны кэш или очереди.

---

### Операционная система

Symfony работает на:

- macOS
- Linux
- Windows

Для этого репозитория можно явно указать:

> В примерах далее предполагается работа на macOS (но шаги легко адаптируются под Linux/Windows).

---

### Быстрая самопроверка окружения

После установки всего необходимого можно проверить окружение командой:

symfony check:requirements

Она покажет, всё ли ок для запуска Symfony-проекта и каких расширений/настроек не хватает.

## 5. Быстрый старт на macOS

В этом разделе — минимальный набор шагов, чтобы запустить первый проект на Symfony на macOS.

### 5.1. Установить Homebrew

Homebrew — это пакетный менеджер для macOS, через него будем ставить всё остальное.

Официальная команда установки (выполнить в терминале):

/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

Проверка, что всё ок:
brew --version

---

### 5.2. Установить PHP

Через Homebrew ставим актуальную версию PHP:

brew install php

Проверяем версию:
php -v

(Если нужно явно, например php@8.3:
brew install php@8.3)

---

### 5.3. Установить Composer

Composer — менеджер зависимостей для PHP, без него Symfony-проект не живёт.

Установка через Homebrew:
brew install composer

Проверка:
composer -V

---

### 5.4. Установить Symfony CLI

Symfony CLI упростит создание и запуск проектов.

Установка:
brew install symfony-cli/tap/symfony-cli

Проверка:
symfony version

---

### 5.5. Создать новый проект Symfony

Переходим в папку, где хочешь держать проект, и создаём новый:

symfony new my_project --webapp

Либо через Composer (альтернатива):
composer create-project symfony/website-skeleton my_project

После создания:
cd my_project

---

### 5.6. Запуск локального сервера

Проще всего запустить встроенный сервер Symfony:

symfony serve

По умолчанию проект будет доступен по адресу:
http://127.0.0.1:8000
или
http://localhost:8000

Открой этот адрес в браузере — увидишь стартовую страницу Symfony.

---

### 5.7. Быстрая проверка, что всё ок

Внутри проекта выполни:

symfony check:requirements

Если все требования выполнены — окружение готово, можно переходить к изучению структуры проекта и написанию кода.

## 6. Создание нового проекта Symfony

В этом разделе — как именно создать новый проект Symfony разными способами и что означают варианты установки.

### 6.1. Вариант через Symfony CLI (рекомендуется)

Если установлен Symfony CLI, самый простой способ:

symfony new my_project --webapp

Здесь:
- my_project — имя папки/проекта (можно поменять).
- --webapp — готовый “полный” скелет: контроллеры, Twig, Doctrine, безопасность и т.п.

После создания:
cd my_project

---

### 6.2. Вариант через Composer

Если по какой-то причине не хочешь использовать Symfony CLI, можно создать проект напрямую через Composer.

Классический “website skeleton” (почти то же, что --webapp):

composer create-project symfony/website-skeleton my_project

Более минималистичный старт (только базовый фреймворк):

composer create-project symfony/skeleton my_project

Этот вариант ставит минимальную конфигурацию, а всё остальное ты добавляешь сам через composer require.

---

### 6.3. Добавление типичных пакетов к skeleton

Если начал с минимального symfony/skeleton, полезные команды:

Добавить поддержку веб-приложения (Twig, WebProfiler и т.п.):
composer require webapp

Добавить Doctrine ORM:
composer require orm

Добавить Twig (если ещё нет):
composer require twig

Добавить поддержку формы и валидации:
composer require form validator

---

### 6.4. Инициализация Git-репозитория

Часто сразу после создания проекта имеет смысл инициализировать Git:

cd my_project
git init
git add .
git commit -m "Initial Symfony project"

Можно упомянуть это прямо в README как рекомендуемый шаг, чтобы пользователю было проще стартовать и версионировать код.

---

### 6.5. Запуск проекта после создания

После любых вариантов создания проекта, для запуска локального сервера:

symfony serve

или, если без Symfony CLI:
php -S 127.0.0.1:8000 -t public

После этого открывай в браузере:
http://127.0.0.1:8000
или
http://localhost:8000

---

### 6.6. Что дальше?

После успешного запуска базового проекта логично перейти к разделам:

- “Структура проекта” — чтобы понять, какие папки за что отвечают.
- “Основы разработки на Symfony” — первый маршрут, контроллер и шаблон.

## 7. Структура проекта Symfony

После создания проекта Symfony внутри папки ты увидишь типичную структуру директорий и файлов. Понимание того, “что где лежит”, сильно упрощает работу.

Ниже — обзор основных папок и их назначения.

---

### 7.1. /bin

Содержит исполняемые файлы, в первую очередь:

- /bin/console — главный CLI-инструмент проекта.
  Через него запускаются команды:
  - миграции
  - генерация кода
  - очистка кэша
  - запуск тестов и т.п.

Примеры:
php bin/console cache:clear
php bin/console debug:router

---

### 7.2. /config

Все конфигурационные файлы проекта:

- /config/packages/ — настройки отдельных бандлов и компонентов (doctrine.yaml, twig.yaml, security.yaml и т.д.).
- /config/routes.yaml — маршруты по умолчанию.
- /config/routes/ — дополнительные файлы маршрутов (если разбиваешь по модулям).
- /config/services.yaml — регистрация сервисов, настройка автоконфигурации/автовызова.

Именно здесь задаётся большая часть “поведения” приложения: какие сервисы включены, какие бандлы активны, как настроены компоненты.

---

### 7.3. /public

Это “публичная” директория — документ-рутовая папка веб-сервера.

- index.php — front controller, точка входа для всех HTTP-запросов.

Именно эту папку должен видеть nginx/Apache/докерный веб-контейнер. Всё, что доступно пользователю через браузер (CSS, JS, картинки), обычно попадает сюда:

- /public/build — скомпилированные ассеты (если используешь Webpack Encore/Vite).
- /public/assets — статические файлы.

---

### 7.4. /src

Основной исходный код приложения.

Обычно содержит:

- /src/Controller — контроллеры (классы, обрабатывающие HTTP-запросы).
- /src/Entity — сущности Doctrine (модели данных, связанные с таблицами БД).
- /src/Repository — классы-репозитории для работы с БД.
- /src/Security — классы, связанные с безопасностью (User, Voter и т.п.).
- /src/Service (или /src/Application, /src/Domain и т.п.) — твои собственные сервисы и бизнес-логика.

Идея: контроллеры “тонкие”, бизнес-логика и работа с доменом — в сервисах/модулях внутри src.

---

### 7.5. /templates

Шаблоны Twig для отображения HTML, email и т.п.

- /templates/base.html.twig — базовый шаблон (layout), от которого наследуются остальные.
- /templates/controller_name/ — папки по контроллерам/модулям.
- /templates/security/ и т.д. — шаблоны для конкретных частей приложения.

Контроллер обычно возвращает рендер шаблона:
например, render('home/index.html.twig', ...)

---

### 7.6. /migrations

Файлы миграций базы данных (если используешь Doctrine Migrations).

Каждый файл описывает изменения схемы БД:
создание таблиц, изменение колонок, добавление индексов и т.п.

Примеры команд:
php bin/console make:migration
php bin/console doctrine:migrations:migrate

---

### 7.7. /var

Временные и служебные файлы:

- /var/cache — кэш приложения (отдельно для окружений dev/prod/test).
- /var/log — логи приложения.
- /var/sessions — сессии (если конфигурация настроена на файловое хранение).

Эта папка не должна попадать в репозиторий (обычно добавлена в .gitignore).

---

### 7.8. /vendor

Все зависимости, установленные через Composer.

- Symfony Framework Bundle
- Doctrine
- Twig
- прочие библиотеки и компоненты

Эта папка не коммитится в Git (также в .gitignore), её можно восстановить командой:
composer install

---

### 7.9. Файлы верхнего уровня

В корне проекта обычно есть:

- composer.json — список зависимостей и конфигурация Composer.
- composer.lock — “зафиксированные” версии пакетов.
- symfony.lock — список пакетов и рецептов Symfony Flex.
- .env — базовые ENV-переменные (под dev-окружение).
- .gitignore — список файлов/папок, игнорируемых Git.
- README.md — описание проекта.

---

### 7.10. Что важно запомнить вначале

Минимальный набор для старта:

- Контроллеры — в src/Controller
- Шаблоны — в templates/
- Маршруты и конфигурация — в config/
- Статика и точка входа — в public/

Понимая эту структуру, дальше гораздо проще читать примеры и документацию Symfony.

## 8. Основы разработки на Symfony

В этом разделе — минимальный набор шагов, чтобы понять “как писать код” на Symfony: маршруты, контроллеры, шаблоны и первые сервисы.

---

### 8.1. Первый маршрут

В Symfony маршрут связывает URL с методом контроллера.

Есть несколько способов описывать маршруты:
- атрибуты (PHP 8) прямо в коде контроллера
- config/routes.yaml
- отдельные yaml-файлы в config/routes/

Чаще всего в новых проектах используют атрибуты.

Пример (идея, не вставляй как есть — ниже будет полный контроллер):
#[Route('/hello', name: 'app_hello')]

Этот маршрут говорит:
- по адресу /hello
- вызывать метод, над которым стоит атрибут
- имя маршрута app_hello (используется для генерации URL в шаблонах и редиректах)

---

### 8.2. Первый контроллер

Контроллер — это обычный PHP-класс в src/Controller, который возвращает HTTP-ответ.

Типичный пример контроллера:

namespace App\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;

class HelloController extends AbstractController
{
    #[Route('/hello', name: 'app_hello')]
    public function index(): Response
    {
        return new Response('Hello, Symfony!');
    }
}

Смысл:
- класс HelloController лежит в src/Controller
- метод index вызывается, когда пользователь открывает /hello
- возвращается объект Response с текстом

---

### 8.3. Ответ через шаблон Twig

Чаще всего контроллер не пишет HTML руками, а рендерит шаблон.

Пример контроллера с Twig:

public function index(): Response
{
    return $this->render('hello/index.html.twig', [
        'name' => 'Symfony',
    ]);
}

Здесь:
- render — метод из AbstractController
- 'hello/index.html.twig' — путь к шаблону (templates/hello/index.html.twig)
- массив с данными (name) будет доступен внутри шаблона

---

### 8.4. Первый Twig-шаблон

Создай файл templates/hello/index.html.twig со следующим содержимым (пример):

{% extends 'base.html.twig' %}

{% block title %}Hello{% endblock %}

{% block body %}
    <h1>Hello, {{ name }}!</h1>
{% endblock %}

Смысл:
- extends 'base.html.twig' — наследуется от основного layout
- block title / block body — заполняет секции, определённые в base.html.twig
- {{ name }} — выводит переменную, переданную из контроллера

---

### 8.5. Генерация URL по имени маршрута

Вместо того чтобы хардкодить ссылку /hello, лучше использовать имя маршрута.

В Twig:
<a href="{{ path('app_hello') }}">Перейти на /hello</a>

В контроллере (например, для редиректа):
return $this->redirectToRoute('app_hello');

Так проще менять URL в будущем: ты меняешь путь в маршруте, а имя маршрута — нет.

---

### 8.6. Работа с Request и параметрами

Метод контроллера может принимать объект Request и параметры маршрута.

Пример маршрута с параметром:
#[Route('/hello/{name}', name: 'app_hello_name')]

Контроллер:

public function index(string $name): Response
{
    return $this->render('hello/index.html.twig', [
        'name' => $name,
    ]);
}

Важно:
- параметр {name} в маршруте автоматически передаётся аргументом в метод
- можно также принимать Request и работать с query-параметрами, POST-данными и т.п.

---

### 8.7. Сервисы и внедрение зависимостей (DI)

Вся полезная логика обычно выносится из контроллеров в сервисы (классы в src/Service или других каталогах).

Пример сервиса:

namespace App\Service;

class GreetingService
{
    public function getGreeting(string $name): string
    {
        return 'Hello, ' . $name . '!';
    }
}

Если в config/services.yaml включён автowired/автоконфиг, ты можешь просто добавить этот сервис как аргумент в контроллер:

use App\Service\GreetingService;

public function index(GreetingService $greetingService): Response
{
    $text = $greetingService->getGreeting('Symfony');

    return new Response($text);
}

Symfony сам создаст экземпляр GreetingService и передаст его в метод контроллера.

Идея:
- контроллер превращается в тонкий слой
- бизнес-логика лежит в сервисах
- тестировать сервис намного проще

---

### 8.8. Основные команды для разработки

Пара команд, которыми ты будешь пользоваться постоянно:

Запуск локального сервера:
symfony serve

Просмотр всех маршрутов:
php bin/console debug:router

Очистка кэша:
php bin/console cache:clear

Создание контроллера (если установлен maker-bundle):
php bin/console make:controller

---

### 8.9. Минимальный “путь” новичка

1) Создать маршрут (атрибут #[Route(...)] в контроллере).
2) Написать метод контроллера, который возвращает Response или рендерит Twig-шаблон.
3) Создать шаблон в templates/ и отобразить данные.
4) При необходимости — вынести логику в сервис и внедрить его через аргументы метода.
5) Посмотреть маршрут через debug:router и открыть его в браузере.

Овладев этими шагами, ты уже умеешь создавать простые страницы, выводить данные и организовывать структуру кода “по-взрослому”.

## 9. Работа с базой данных (Doctrine ORM)

Symfony обычно работает с базой данных через Doctrine ORM — это слой, который позволяет описывать таблицы в виде PHP-классов (сущностей) и писать минимум “сырого” SQL.

---

### 9.1. Подключение базы данных через .env

В корне проекта есть файл .env. В нём задаётся строка подключения к БД:

DATABASE_URL="mysql://username:password@127.0.0.1:3306/db_name?serverVersion=8.0"

Примеры:
- MySQL / MariaDB:
  DATABASE_URL="mysql://root:password@127.0.0.1:3306/my_db?serverVersion=8.0"
- PostgreSQL:
  DATABASE_URL="postgresql://user:password@127.0.0.1:5432/my_db?serverVersion=15&charset=utf8"
- SQLite:
  DATABASE_URL="sqlite:///%kernel.project_dir%/var/data.db"

Для локальной разработки часто достаточно SQLite или локального MySQL/PostgreSQL.

---

### 9.2. Создание сущности (Entity)

Сущность — это PHP-класс, который описывает таблицу БД.

Если установлен maker-bundle (обычно так и есть в webapp-проектах), то сущность можно сгенерировать командой:

php bin/console make:entity

Далее CLI предложит:
- имя сущности (например, Article)
- поля (title, content, createdAt и т.п.)
- типы полей (string, text, datetime, boolean и т.д.)

В итоге появится класс в src/Entity/Article.php.

---

### 9.3. Миграции базы данных

После изменения сущностей нужно обновить схему базы данных.

Шаги:

1) Сгенерировать миграцию:
php bin/console make:migration

2) Применить миграцию:
php bin/console doctrine:migrations:migrate

Доктрина сравнит текущую схему БД с описанием сущностей и подготовит SQL для обновления.

---

### 9.4. Репозитории (Repository)

Для каждой сущности Doctrine может создать репозиторий — класс для работы с БД.

Если сущность создавалась через make:entity, обычно репозиторий генерируется автоматически в src/Repository/ArticleRepository.php.

Через репозиторий можно:
- находить записи: find(), findOneBy(), findAll(), findBy()
- писать свои запросы (DQL/QueryBuilder)

Пример:
$articles = $articleRepository->findAll();

---

### 9.5. Простейший CRUD-поток

Схематично:

1) Создать сущность (make:entity Article).
2) Создать миграцию и применить её (make:migration + doctrine:migrations:migrate).
3) В контроллере или сервисе:
   - создать объект сущности: $article = new Article(...);
   - получить EntityManager: $em = $this->getDoctrine()->getManager(); (или через DI);
   - сохранить:
     $em->persist($article);
     $em->flush();
4) Для чтения:
   - внедрить ArticleRepository и вызвать методы поиска (find, findAll и т.п.).
5) Для обновления:
   - изменить свойства объекта и снова вызвать $em->flush();
6) Для удаления:
   - $em->remove($article);
   - $em->flush();

В более “чистом” подходе вся эта логика уезжает в отдельные сервисы, а контроллер только вызывает их методы.

---

### 9.6. Полезные команды Doctrine

Проверка подключения к БД:
php bin/console doctrine:database:create
php bin/console doctrine:database:drop --force

Синхронизация схемы (если очень нужно, но обычно используют миграции):
php bin/console doctrine:schema:update --force

Создание миграции:
php bin/console make:migration

Применение миграций:
php bin/console doctrine:migrations:migrate

---

Минимальная идея этого раздела:
- .env хранит строку подключения к БД,
- сущности в src/Entity описывают таблицы,
- миграции меняют структуру БД,
- репозитории и EntityManager позволяют удобно читать и изменять данные.

## 10. Запуск, кэш, отладка и профилирование

Этот раздел про то, как “живет” Symfony-приложение во время разработки: как его запускать, где кэш, как смотреть профилировщик и логи.

---

### 10.1. Запуск локального сервера

Самый простой способ запустить проект в dev-режиме — использовать Symfony CLI.

В корне проекта:

symfony serve

По умолчанию приложение будет доступно по адресу:
http://127.0.0.1:8000
или
http://localhost:8000

Остановка сервера:
Ctrl + C в терминале.

Если Symfony CLI не используется, можно запустить встроенный PHP-сервер:

php -S 127.0.0.1:8000 -t public

---

### 10.2. Окружения: dev и prod

Symfony работает в разных окружениях:

- dev — окружение для разработки:
  - включен дебаг
  - детальные страницы ошибок
  - профилировщик, toolbar внизу страницы
  - меньше кэширования

- prod — окружение для продакшена:
  - дебаг отключен
  - включен максимальный кэш
  - ошибки логируются, но не показываются пользователю

Окружение задаётся переменной APP_ENV (в файле .env, .env.local или в настройках сервера).

Примеры:
APP_ENV=dev
APP_ENV=prod

---

### 10.3. Кэш приложения

Symfony активно использует кэш (конфигурация, маршруты, Twig-шаблоны и т.д.).

Папка кэша:
var/cache

Обычно делится по окружениям:
var/cache/dev
var/cache/prod

Очистить кэш (в dev или prod окружении):

php bin/console cache:clear

Иногда после изменения конфигурации или окружения полезно чистить кэш вручную.

---

### 10.4. Логи приложения

Логи находятся в папке:
var/log

Файл:
var/log/dev.log — для dev окружения
var/log/prod.log — для prod окружения

Там можно увидеть:
- ошибки
- предупреждения
- полезную отладочную информацию

Если приложение “падает” без понятного объяснения в браузере — почти всегда есть подсказка в логах.

---

### 10.5. Web Debug Toolbar

В dev-режиме внизу каждой страницы появляется панель “Web Debug Toolbar” — тонкая полоска с информацией.

Она показывает:
- время выполнения запроса
- используемую память
- статус-код HTTP
- маршруты
- SQL-запросы
- логи
- Twig-шаблоны
- события, слушателей и многое другое

Кликнув по панели, можно открыть полный профилировщик для конкретного запроса.

---

### 10.6. Профилировщик запросов

Профилировщик — это отдельная страница, которая показывает полную информацию о запросе.

Через него можно:
- смотреть список всех SQL-запросов (время выполнения, параметры)
- видеть дерево Twig-шаблонов
- изучать роутинг и совпадение маршрута
- смотреть логи, события, состояние контейнера

Он очень полезен на этапе отладки производительности и поиска проблем.

---

### 10.7. Команды для дебага

Symfony даёт ряд команд, которые помогут понять, “что происходит” внутри проекта.

Примеры:

Просмотр всех маршрутов:
php bin/console debug:router

Просмотр зарегистрированных служб (сервисов) контейнера:
php bin/console debug:container

Просмотр параметров конфигурации:
php bin/console debug:config framework

Проверка требований:
symfony check:requirements

---

### 10.8. Сборка ассетов (если используется фронтенд-сборщик)

Если в проекте используется Webpack Encore, Vite или другой сборщик для CSS/JS, обычно есть команды вида:

npm install
npm run dev
npm run build

Сборка ассетов кладёт файлы в public/build или другую указанную папку, откуда они раздаются браузеру.

---

### 10.9. Минимальный “цикл” разработки

Типичный цикл во время разработки:

1) Изменить код (контроллер, шаблон, сервис).
2) Обновить страницу — Symfony в dev-режиме подхватывает изменения автоматически.
3) Если что-то “странно себя ведёт” — заглянуть в Web Debug Toolbar и профилировщик.
4) При конфигурационных изменениях — при необходимости почистить кэш:
   php bin/console cache:clear
5) Проверить логи в var/log/dev.log, если есть ошибки или исключения.

Понимая, как запускать сервер, чистить кэш и пользоваться профилировщиком, разработка на Symfony становится намного комфортнее.

## 11. Создание API на Symfony

Symfony отлично подходит не только для “классических” веб-страниц с HTML, но и для построения REST/JSON API. Ниже — базовая схема, как сделать простой API и куда двигаться дальше.

---

### 11.1. Простой JSON-эндпоинт

Чтобы сделать API-метод, не обязательно подключать какие-то особые модули — достаточно вернуть JSON-ответ из контроллера.

Пример контроллера (идея):

namespace App\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\Routing\Annotation\Route;

class ApiDemoController extends AbstractController
{
    #[Route('/api/ping', name: 'api_ping', methods: ['GET'])]
    public function ping(): JsonResponse
    {
        return $this->json([
            'status' => 'ok',
            'message' => 'pong',
        ]);
    }
}

Смысл:
- маршрут /api/ping
- метод отвечает только на GET-запросы (methods: ['GET'])
- $this->json(...) — удобный способ вернуть JSON-ответ с правильными заголовками

---

### 11.2. Структура URL для API

Часто API роуты группируют по префиксу /api.

Примеры:
- /api/users
- /api/articles
- /api/auth/login

Можно:
- либо явно указывать префикс /api для каждого маршрута,
- либо настроить общий префикс в config/routes.yaml для файлов с API-маршрутами.

---

### 11.3. CRUD для сущностей через контроллер

Если уже есть сущность (например, Article), на основе неё можно сделать простой REST-подобный API:

- GET /api/articles — список статей
- GET /api/articles/{id} — детальная информация
- POST /api/articles — создание
- PUT/PATCH /api/articles/{id} — обновление
- DELETE /api/articles/{id} — удаление

Логика:
1) В контроллере или сервисе использовать репозиторий (ArticleRepository) для чтения.
2) Для создания/обновления — читать JSON-тело из запроса (Request->getContent()), декодировать его и заполнять сущность.
3) Сохранять через EntityManager (persist/flush), как в разделах про Doctrine.
4) Возвращать JsonResponse с объектами/данными.

---

### 11.4. Чтение JSON из Request

Symfony даёт удобный объект Request.

Типичный сценарий в API-контроллере:

- получить сырое тело запроса:
  $data = json_decode($request->getContent(), true);

- прочитать поля:
  $title = $data['title'] ?? null;

Дальше на основе этих данных создаёшь или изменяешь сущность и сохраняешь её в БД.

---

### 11.5. Формат ответов и коды статусов

API должен возвращать не только данные, но и корректные HTTP-коды:

- 200 OK — успешный GET/PUT/DELETE
- 201 Created — успешное создание ресурса (POST)
- 400 Bad Request — некорректные данные
- 404 Not Found — ресурс не найден
- 500 Internal Server Error — внутренняя ошибка

В JsonResponse можно указать статус-код вторым аргументом.

Пример:
return $this->json(['error' => 'Not found'], 404);

---

### 11.6. Сериализация данных

Когда сущность становится сложнее, вручную собирать массивы для JSON утомительно.

Symfony умеет сериализовать объекты:
- либо через компонент Serializer (если его подключить),
- либо через бандлы (например, API Platform или JMS Serializer).

Идея:
- ты описываешь, какие поля и в каком виде должны попадать в JSON,
- сериализатор автоматически преобразует объект в массив/JSON.

---

### 11.7. Авторизация и защита API

Для “настоящих” API почти всегда нужна авторизация:

- простые варианты:
  - session + cookie (но для API это редко используют),
- более распространённые:
  - Bearer токены (JWT, обычные токены),
  - OAuth2 (через отдельные бандлы/сервисы).

Защита маршрутов настраивается в security.yaml:
- задаются “firewalls”,
- указываются способы аутентификации,
- маршруты привязываются к ролям (ROLE_USER, ROLE_ADMIN и т.п.).

---

### 11.8. Версионирование API

При развитии API часто используют версионирование:

- /api/v1/...
- /api/v2/...

Это можно сделать:
- либо префиксами в маршрутах,
- либо разными контроллерами/пространствами имён.

Важно: думать о версиях заранее, если API должен жить долго и меняться, не ломая старых клиентов.

---

### 11.9. Быстрый старт с API Platform (опционально)

API Platform — это отдельный набор инструментов поверх Symfony, который позволяет:

- очень быстро поднимать REST и GraphQL API “из сущностей”,
- автоматически генерировать документацию (OpenAPI/Swagger),
- получать готовый CRUD по аннотациям/атрибутам.

Если цель репозитория — именно “быстро показать API на Symfony”, можно:
- сначала показать “ручной” подход (этот раздел),
- а потом отдельным подразделом упомянуть API Platform как “турбо-режим” для более сложных проектов.

---

### 11.10. Минимальный путь для первого API

1) Создать простой контроллер с маршрутом /api/ping, возвращающий JSON.
2) Добавить маршрут, работающий с сущностью (например, /api/articles).
3) Научиться читать JSON из Request и валидировать данные.
4) Возвращать осмысленные коды ответов (201, 400, 404).
5) По мере усложнения — подключить сериализатор и продумать авторизацию.

Этого уже достаточно, чтобы сделать маленький, но рабочий API на Symfony.

## 12. Работа с окружениями (env)

В Symfony очень важно правильно работать с окружениями — это определяет, как ведёт себя приложение в dev, prod и test режимах.

---

### 12.1. Основные окружения

По умолчанию используются три окружения:

- dev — разработка:
  - детальные страницы ошибок
  - включён Web Debug Toolbar
  - много логов, минимальное кэширование

- prod — продакшен:
  - нет подробных ошибок в браузере
  - включён агрессивный кэш
  - оптимизированная автозагрузка

- test — для тестов:
  - отдельная конфигурация
  - свои БД/файлы/кэш

Текущее окружение задаётся переменной APP_ENV.

---

### 12.2. Файлы .env и .env.local

В корне проекта есть несколько файлов окружения:

- .env
  - базовые настройки по умолчанию
  - обычно под dev-окружение
- .env.local
  - локальные переопределения (не коммитится)
  - сюда кладут пароли, локальные БД и т.п.
- .env.prod, .env.test и т.п. (опционально)
  - если хочется явно разделить конфиги по файлам

Важно:
- .env хранится в репозитории
- .env.local добавлен в .gitignore, и у каждого разработчика может быть свой

---

### 12.3. Переменные окружения

Ключевые переменные:

- APP_ENV
  - определяет окружение: dev, prod, test
- APP_DEBUG
  - включает/выключает режим отладки (true/false)
- DATABASE_URL
  - строка подключения к базе данных
- APP_SECRET
  - секретный ключ для подписей, CSRF и др.

Пример базового блока в .env:

APP_ENV=dev
APP_DEBUG=1
APP_SECRET=some_random_secret

В .env.local можно переопределить, например:

APP_ENV=dev
APP_DEBUG=1
DATABASE_URL="mysql://root:password@127.0.0.1:3306/my_db?serverVersion=8.0"

---

### 12.4. Окружение для консольных команд

При запуске bin/console Symfony смотрит на APP_ENV.

По умолчанию:
- если APP_ENV в .env = dev, команды выполняются в dev-режиме.

Можно явно указать окружение:

APP_ENV=prod php bin/console cache:clear

Или задать переменную в окружении вашей оболочки (zsh, bash и т.п.)

---

### 12.5. Конфигурация по окружениям

В папке config/packages/ можно задавать разные конфиги для разных окружений.

Примеры:
- config/packages/twig.yaml
- config/packages/dev/twig.yaml
- config/packages/prod/monolog.yaml

Symfony автоматически подхватывает файлы из подпапок dev/, prod/, test/ в зависимости от APP_ENV.

Это позволяет:
- включать дополнительные панели в dev
- отключать их в prod
- по-разному настраивать логирование, кэш, профилировщик и т.п.

---

### 12.6. Кэш для разных окружений

Кэш лежит в:

var/cache/dev
var/cache/prod
var/cache/test

Отдельные папки для каждого окружения.

Очистка кэша для конкретного окружения:

APP_ENV=prod php bin/console cache:clear

или в dev (если APP_ENV=dev по умолчанию):

php bin/console cache:clear

---

### 12.7. Подготовка prod-окружения

При деплое в prod обычно делают:

1) Устанавливают зависимости без dev-пакетов и с оптимизацией автозагрузки:
   composer install --no-dev --optimize-autoloader

2) Указывают APP_ENV=prod и APP_DEBUG=0 в переменных окружения сервера или .env.prod.local.

3) Прогревают кэш:
   APP_ENV=prod php bin/console cache:clear

4) Применяют миграции:
   APP_ENV=prod php bin/console doctrine:migrations:migrate

---

### 12.8. Минимальные правила работы с env

1) В .env храним “безопасные” значения по умолчанию (обычно dev).
2) В .env.local — личные локальные настройки (пароли, локальные БД).
3) Для продакшена:
   - значения в переменные окружения сервера
   - либо отдельные файлы .env.prod.local (не в репозитории).
4) Всегда помни, в каком окружении сейчас работаешь (dev vs prod), чтобы не “убить” продакшен командой типа drop database.

Понимание механизма env-файлов и окружений — один из ключевых моментов в работе с Symfony в реальных проектах.

